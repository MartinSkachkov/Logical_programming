% четно_позиционирани(X,Y) - Y e СПИСЪК от елементите на X, които ce
%                            намират на четна позиция
% X=[1,2,3,4] Y=[2,4]
% Условие: известна е дължината на Х или на Y.
четно_позиционирани([],[]).
четно_позиционирани([_|X],Y) :- нечетно_позщионирани(X,Y).
  
% нечетно_позиционирани(х,Y)-Y e СПИСЪК от елементите на X, които ce
%                               намират на нечетна позиция
% X=[1,2,3,4] Y=[1,3]                           
% Условие: поне един от аргументите e с известен брой елементи.
нечетно_позщионирани([],[]).
нечетно_позщионирани([A|X],[A|Y]) :- четно_позиционирани(X,Y).

% елемент(A,X) - A e елемент на списъка X (в пролог e вграден като member)
% Условие: известно е ограничение отгоре за дължината на Х.
elem(A,[A|_]).
elem(A,[_|X]) :- elem(A,X).

% конкат(Х, Y, Z) - списъкът Z e конкатенация на списъците X и Y (в пролог e вграден като append)
% X=[1,2,3] Y=[4,5,6] -> Z=[1,2,3,4,5,6]
% Условие: известно е ограничение отгоре за дължината на Х или на Z.
concat([],Y,Y).
concat([A|X],Y,[A|Z]) :- concat(X,Y,Z).

% последен(А, X) - A e последният елемент на X
% Условие: известно е ограничение отгоре за дължината на Х.
last(A,X) :- concat(_,[A],X).

% предпоследен(А, X) - A e предпоследният елемент на X
% Условие: известно е ограничение отгоре за дължината на Х.
bfr_last(A,X) :- concat(_,[A,_],X).

% префикс(Х, Y) - списъкът X e начало на Y
% Условие: известно е ограничение отгоре за дължината на Х или на Y.
pref([],_).
pref([A|X],[A|Y]) :- pref(X,Y).

pref2(X,Y) :- concat(X,_,Y).

% ротация(Х,Y) - Y е ротация на Х
% Условие: известно е ограничение отгоре за дължината на Х или на Y.
rotation(X,Y) :- concat(X1,X2,X), concat(X2,X1,Y).

% пермутация (X, Y) - списъкът Y e пермутация на X
% X=[1,2,3] Y=[3,1,2]
% Условие: известно е ограничение отгоре за дължината на Х.
permut([],[]).
permut([A|X],Y) :- permut(X,Z), insert(A,Z,Y).
    
% вмък(A, X, Y) - списъкът Y ce получава като вмъкнем A в X на произволна позиция.
% Условие: известно e ограничение отгоре за дължината на X.
insert(A,X,Y) :- concat(X1,X2,X), concat(X1,[A|X2],Y).

% Условие: известно е ограничение отгоре за дължината на Х(понеже ще трябва да е известно за remove).
permut2([],[]).
permut2(X,[A|Y]) :- remove(X,A,Z), permut2(Z,Y).

% измък(X, A, Y) - списъкът Y ce получава като измъкнем от X произволен елемент A
% Условие: известно e ограничение отгоре за дължината на X.
remove(X,A,Y) :- concat(X1,[A|X2],X), concat(X1,X2,Y).

% равна_дължина(X, Y) - списъкът Х и списъкът Y са с равна дължина.
% Условие: известно е ограничение отгоре за дължината на X и Y.
same_length([],[]).
same_length([_|X],[_|Y]) :- same_length(X,Y).

% за всяка двойка последователни числа на списъка Х, трябва да са в релация A #=< B
:- use_module(library(clpfd)).
сорт(X,Y) :- permut(X,Y), forall(append(_,[A,B|_],Y), A #=< B).

max_el(X,E) :- member(E,X), label([E]), forall(member(B,X), E #>= B).
min_el(X,E) :- member(E,X), label([E]), forall(member(B,X), B #>= E).
















